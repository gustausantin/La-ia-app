{
  "name": "01 - Check Availability (OPTIMIZADO)",
  "nodes": [
    {
      "parameters": {
        "inputSource": "jsonExample",
        "jsonExample": "{\n  \"date\": \"2025-10-19\",\n  \"time\": \"20:00\",\n  \"party_size\": 4,\n  \"preferred_zone\": \"terraza\",\n  \"restaurant_id\": \"d6b63130-1ebf-4284-98fc-a3b31a85d9d1\"\n}"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -752,
        -96
      ],
      "id": "76bd0e89-6b7d-4b1c-b573-169e86b8e81e",
      "name": "Start",
      "notes": "‚úÖ Acepta preferred_zone (opcional)"
    },
    {
      "parameters": {
        "jsCode": "// =====================================================\n// üîç VALIDACI√ìN DE INPUT CON SOPORTE DE ZONAS\n// =====================================================\n// NOTA: La validaci√≥n de tiempo m√≠nimo se hace en la RPC find_table_combinations\n// que obtiene el valor din√°micamente de restaurants.settings.min_advance_minutes\n// =====================================================\n\nconst input = $input.first().json;\n\nconsole.log('üì• Input recibido:', input);\n\n// ===== VALIDAR FECHA =====\nconst fecha = input.date || input.reservation_date || '';\n\nif (!fecha || !/^\\d{4}-\\d{2}-\\d{2}$/.test(fecha)) {\n  throw new Error('Formato de fecha inv√°lido. Se requiere YYYY-MM-DD');\n}\n\nconst hoy = new Date().toISOString().split('T')[0];\nif (fecha < hoy) {\n  throw new Error('No se puede consultar disponibilidad en fechas pasadas');\n}\n\n// ===== VALIDAR HORA =====\nconst hora = input.time || input.reservation_time || '';\n\nif (!hora || !/^\\d{2}:\\d{2}(:\\d{2})?$/.test(hora)) {\n  throw new Error('Formato de hora inv√°lido. Se requiere HH:MM');\n}\n\nconst horaNormalizada = hora.substring(0, 5);\n\n// ===== VALIDAR PERSONAS =====\nconst personas = parseInt(input.party_size || input.people || 0);\n\nif (!personas || personas < 1 || personas > 20) {\n  throw new Error('N√∫mero de personas debe estar entre 1 y 20');\n}\n\n// ===== VALIDAR RESTAURANT_ID =====\nconst restaurant_id = input.restaurant_id || '';\n\nif (!restaurant_id) {\n  throw new Error('restaurant_id es obligatorio');\n}\n\n// ===== CALCULAR TIEMPO HASTA RESERVA (para informaci√≥n) =====\nconst now = new Date();\nconst reservationDateTime = new Date(`${fecha}T${horaNormalizada}:00`);\nconst minutesUntil = (reservationDateTime - now) / (1000 * 60);\n\nconsole.log(`‚è∞ Reserva en ${Math.round(minutesUntil)} minutos. La RPC validar√° el m√≠nimo configurado.`);\n\n// ===== VALIDAR Y NORMALIZAR ZONA =====\nconst zonaRaw = input.preferred_zone || input.zone || input.reservation_location || input.location || null;\nconst validZones = ['interior', 'terraza', 'barra', 'privado', 'any'];\nlet zona = null;\n\nif (zonaRaw) {\n  const zonaNormalizada = zonaRaw.toLowerCase().trim();\n  if (validZones.includes(zonaNormalizada)) {\n    zona = zonaNormalizada === 'any' ? null : zonaNormalizada;\n    console.log(`‚úÖ Zona v√°lida: ${zona || 'todas'}`);\n  } else {\n    console.log(`‚ö†Ô∏è Zona inv√°lida: \"${zonaRaw}\". Se buscar√° en todas las zonas.`);\n    zona = null;\n  }\n}\n\nconsole.log('‚úÖ Validado:', { fecha, hora: horaNormalizada, personas, zona: zona || 'todas', restaurant_id, minutesUntil: Math.round(minutesUntil) });\n\nreturn {\n  fecha,\n  hora: horaNormalizada,\n  personas,\n  zona,\n  restaurant_id,\n  fecha_formateada: new Date(fecha).toLocaleDateString('es-ES', { \n    weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' \n  }),\n  minutes_until_reservation: Math.round(minutesUntil)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -560,
        -96
      ],
      "id": "3aeea934-02c6-4ef1-b5c4-5812f9ad9ed7",
      "name": "üîç Validar Input",
      "notes": "‚úÖ Valida zona (opcional)"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "availability_slots",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "restaurant_id",
              "condition": "eq",
              "keyValue": "={{ $json.restaurant_id }}"
            },
            {
              "keyName": "slot_date",
              "condition": "eq",
              "keyValue": "={{ $json.fecha }}"
            },
            {
              "keyName": "status",
              "condition": "eq",
              "keyValue": "free"
            },
            {
              "keyName": "start_time",
              "condition": "eq",
              "keyValue": "={{ $json.hora }}"
            },
            {
              "keyName": "zone",
              "condition": "eq",
              "keyValue": "={{ $json.zona }}"
            },
            {
              "keyName": "capacity",
              "condition": "gte",
              "keyValue": "={{ $json.personas }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -368,
        -96
      ],
      "id": "190813d6-cb6e-4267-b624-b42fb0f62e1b",
      "name": "üìç Buscar Slots Disponibles",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "9pdl4V7ImejCLZWo",
          "name": "Supabase La-IA"
        }
      },
      "continueOnFail": true,
      "notes": "‚úÖ OPTIMIZADO: Filtra por capacity directamente en BD"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "tiene-slots",
              "leftValue": "={{ $input.all().length }}",
              "rightValue": "0",
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -176,
        -96
      ],
      "id": "dd5a8670-8a83-4813-99cc-5d16cbb33b03",
      "name": "‚ùì ¬øHay Slots?",
      "notes": "Bifurcaci√≥n: Disponible vs No disponible"
    },
    {
      "parameters": {
        "jsCode": "// =====================================================\n// ‚úÖ RESPUESTA: S√ç HAY DISPONIBILIDAD (OPTIMIZADO)\n// =====================================================\n\nconst validacion = $('üîç Validar Input').first().json;\nconst slots = $input.all();\n\nconst personas = validacion.personas;\nconst zona = validacion.zona;\n\nconsole.log('‚úÖ Slots disponibles:', slots.length);\n\nif (slots.length === 0) {\n  const mensajeBase = `Lo siento, no tenemos mesas con capacidad suficiente para ${personas} personas`;\n  const mensajeZona = zona ? ` en la zona ${zona}` : '';\n  const sugerencia = zona ? ' ¬øTe ir√≠a bien en otra zona?' : '';\n  \n  return {\n    disponible: false,\n    mensaje: `${mensajeBase}${mensajeZona}.${sugerencia}`,\n    alternativas: [],\n    detalles: {\n      fecha: validacion.fecha,\n      hora: validacion.hora,\n      personas: personas,\n      zona_solicitada: zona\n    },\n    accion_sugerida: zona ? 'sugerir_otra_zona' : 'buscar_otra_hora'\n  };\n}\n\n// ‚úÖ OPTIMIZADO: capacity y table_name ya vienen en los slots\nconst mesasDisponibles = slots\n  .map(s => s.json)\n  .sort((a, b) => a.capacity - b.capacity);\n\nconst mejorMesa = mesasDisponibles[0];\n\nconst mensajeZona = zona ? ` en ${zona}` : '';\nconst mensaje = `¬°Perfecto! S√≠ tenemos disponibilidad${mensajeZona} para ${personas} persona${personas > 1 ? 's' : ''} el ${validacion.fecha_formateada} a las ${validacion.hora}. Tenemos ${mesasDisponibles.length} mesa${mesasDisponibles.length > 1 ? 's' : ''} disponible${mesasDisponibles.length > 1 ? 's' : ''}.`;\n\nreturn {\n  disponible: true,\n  mensaje: mensaje,\n  detalles: {\n    fecha: validacion.fecha,\n    hora: validacion.hora,\n    personas: personas,\n    zona_solicitada: zona,\n    mesas_disponibles: mesasDisponibles.length,\n    mejor_opcion: {\n      mesa: mejorMesa.table_name,  // ‚úÖ Directo desde slot\n      capacidad: mejorMesa.capacity,  // ‚úÖ Directo desde slot\n      zona: mejorMesa.zone\n    },\n    todas_las_opciones: mesasDisponibles.map(m => ({\n      mesa: m.table_name,\n      capacidad: m.capacity,\n      zona: m.zone\n    }))\n  },\n  accion_sugerida: 'proceder_con_reserva'\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        -192
      ],
      "id": "fd13a46e-ae85-44a2-88e4-c1890251a428",
      "name": "‚úÖ Respuesta: Disponible",
      "notes": "‚úÖ OPTIMIZADO: Usa capacity y table_name directamente desde slots"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "availability_slots",
        "limit": 200,
        "filters": {
          "conditions": [
            {
              "keyName": "restaurant_id",
              "condition": "eq",
              "keyValue": "={{ $('üîç Validar Input').item.json.restaurant_id }}"
            },
            {
              "keyName": "slot_date",
              "condition": "eq",
              "keyValue": "={{ $('üîç Validar Input').item.json.fecha }}"
            },
            {
              "keyName": "status",
              "condition": "eq",
              "keyValue": "free"
            },
            {
              "keyName": "is_available",
              "condition": "eq",
              "keyValue": "true"
            },
            {
              "keyName": "capacity",
              "condition": "gte",
              "keyValue": "={{ $('üîç Validar Input').item.json.personas }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        0,
        -16
      ],
      "id": "70db53d3-b035-439c-8bab-dffdfbebd6cd",
      "name": "üîé Buscar Alternativas",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "9pdl4V7ImejCLZWo",
          "name": "Supabase La-IA"
        }
      },
      "continueOnFail": true,
      "notes": "‚úÖ OPTIMIZADO: Filtra por capacity directamente"
    },
    {
      "parameters": {
        "jsCode": "// =====================================================\n// ‚ö†Ô∏è RESPUESTA: NO HAY DISPONIBILIDAD (PROFESIONAL)\n// =====================================================\n// Solo ofrece alternativas cercanas (¬±2h, m√°ximo 4 opciones)\n// =====================================================\n\nconst validacion = $('üîç Validar Input').first().json;\nconst alternativas = $input.all();\n\nconst zona = validacion.zona;\nconst personas = validacion.personas;\nconst horaSolicitada = validacion.hora; // formato \"13:00\"\n\nconsole.log('üîç Alternativas encontradas:', alternativas.length);\nconsole.log('üïê Hora solicitada:', horaSolicitada);\n\n// ===== CASO 1: NO HAY ALTERNATIVAS EN TODO EL D√çA =====\nif (alternativas.length === 0) {\n  return {\n    tiene_alternativas: false,\n    mensaje: `Lo siento, no tenemos disponibilidad para ${personas} personas el ${validacion.fecha_formateada}. ¬øTe gustar√≠a que busque en otra fecha?`,\n    disponible: false,\n    alternativas: [],\n    detalles: {\n      fecha_solicitada: validacion.fecha,\n      hora_solicitada: horaSolicitada,\n      personas: personas,\n      zona_solicitada: zona\n    },\n    accion_sugerida: 'sugerir_otra_fecha'\n  };\n}\n\n// ===== HELPER: Convertir \"HH:MM\" a minutos del d√≠a =====\nfunction horaAMinutos(hora) {\n  const [h, m] = hora.split(':').map(Number);\n  return h * 60 + m;\n}\n\n// ===== HELPER: Convertir minutos a \"HH:MM\" =====\nfunction minutosAHora(minutos) {\n  const h = Math.floor(minutos / 60);\n  const m = minutos % 60;\n  return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;\n}\n\nconst minutosHoraSolicitada = horaAMinutos(horaSolicitada);\nconst RANGO_MINUTOS = 120; // ¬±2 horas = 120 minutos\n\n// ===== CASO 2: FILTRAR ALTERNATIVAS CERCANAS (¬±2h) =====\nconst horasPorSlot = {};\nalternativas.forEach(slot => {\n  const hora = slot.json.start_time.substring(0, 5); // \"13:00:00\" ‚Üí \"13:00\"\n  const zonaSlot = slot.json.zone;\n  \n  // Filtrar por zona si se especific√≥\n  if (zona && zonaSlot !== zona) {\n    return;\n  }\n  \n  // Calcular diferencia en minutos\n  const minutosSlot = horaAMinutos(hora);\n  const diferenciaMinutos = Math.abs(minutosSlot - minutosHoraSolicitada);\n  \n  // ‚úÖ SOLO INCLUIR SI EST√Å DENTRO DEL RANGO DE ¬±2H\n  if (diferenciaMinutos > RANGO_MINUTOS) {\n    return;\n  }\n  \n  if (!horasPorSlot[hora]) {\n    horasPorSlot[hora] = {\n      minutos: minutosSlot,\n      diferencia: diferenciaMinutos\n    };\n  }\n});\n\n// ===== CASO 3: ORDENAR POR CERCAN√çA Y TOMAR 2 ANTES + 2 DESPU√âS =====\nconst todasLasHoras = Object.keys(horasPorSlot)\n  .filter(h => h !== horaSolicitada) // Excluir hora solicitada\n  .map(h => ({\n    hora: h,\n    minutos: horasPorSlot[h].minutos,\n    diferencia: horasPorSlot[h].diferencia,\n    esAntes: horasPorSlot[h].minutos < minutosHoraSolicitada\n  }));\n\nconst horasAntes = todasLasHoras\n  .filter(h => h.esAntes)\n  .sort((a, b) => b.minutos - a.minutos) // M√°s cercana primero\n  .slice(0, 2)\n  .map(h => h.hora);\n\nconst horasDespues = todasLasHoras\n  .filter(h => !h.esAntes)\n  .sort((a, b) => a.minutos - b.minutos) // M√°s cercana primero\n  .slice(0, 2)\n  .map(h => h.hora);\n\n// Combinar: 2 antes + 2 despu√©s, en orden cronol√≥gico\nconst horasDisponibles = [...horasAntes.reverse(), ...horasDespues];\n\nconsole.log('‚úÖ Alternativas cercanas (¬±2h):', horasDisponibles);\n\n// ===== CASO 4: SI NO HAY ALTERNATIVAS CERCANAS =====\nif (horasDisponibles.length === 0) {\n  // Verificar si hay en otras zonas\n  if (zona) {\n    const zonasDisponibles = [...new Set(\n      alternativas\n        .map(s => s.json.zone)\n        .filter(z => z && z !== zona)\n    )];\n    \n    if (zonasDisponibles.length > 0) {\n      const listaZonas = zonasDisponibles.join(', ');\n      return {\n        tiene_alternativas: true,\n        disponible: false,\n        mensaje: `Lo siento, no tenemos disponibilidad en ${zona} cerca de las ${horaSolicitada} para ${personas} personas. Sin embargo, s√≠ tenemos disponibilidad en: ${listaZonas}. ¬øTe ir√≠a bien alguna de estas zonas?`,\n        alternativas_zona: zonasDisponibles,\n        detalles: {\n          fecha: validacion.fecha,\n          hora_solicitada: horaSolicitada,\n          personas: personas,\n          zona_solicitada: zona,\n          zonas_alternativas: zonasDisponibles\n        },\n        accion_sugerida: 'elegir_otra_zona'\n      };\n    }\n  }\n  \n  // No hay alternativas cercanas\n  const mensajeZona = zona ? ` en ${zona}` : '';\n  return {\n    tiene_alternativas: false,\n    disponible: false,\n    mensaje: `Lo siento, no tenemos disponibilidad cerca de las ${horaSolicitada}${mensajeZona} para ${personas} personas el ${validacion.fecha_formateada}. ¬øTe gustar√≠a que busque en otra fecha?`,\n    alternativas: [],\n    detalles: {\n      fecha: validacion.fecha,\n      hora_solicitada: horaSolicitada,\n      personas: personas,\n      zona_solicitada: zona\n    },\n    accion_sugerida: 'sugerir_otra_fecha'\n  };\n}\n\n// ===== CASO 5: HAY ALTERNATIVAS CERCANAS =====\nconst listaHoras = horasDisponibles.join(', ');\nconst mensajeZona = zona ? ` en ${zona}` : '';\nconst mensaje = `Lo siento, no tenemos disponibilidad a las ${horaSolicitada}${mensajeZona} para ${personas} personas. Sin embargo, s√≠ tenemos disponibilidad en estos horarios cercanos el ${validacion.fecha_formateada}: ${listaHoras}. ¬øAlguno te vendr√≠a bien?`;\n\nreturn {\n  tiene_alternativas: true,\n  disponible: false,\n  mensaje: mensaje,\n  alternativas_horario: horasDisponibles,\n  detalles: {\n    fecha: validacion.fecha,\n    hora_solicitada: horaSolicitada,\n    personas: personas,\n    zona_solicitada: zona,\n    total_alternativas: horasDisponibles.length,\n    rango_horas: '¬±2h'\n  },\n  accion_sugerida: 'elegir_alternativa'\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        192,
        -16
      ],
      "id": "84a78f6a-0683-485d-9833-7be4cb3dfd84",
      "name": "‚ö†Ô∏è Respuesta: No Disponible",
      "notes": "‚úÖ OPTIMIZADO: Usa capacity directamente desde slots"
    }
  ],
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "üîç Validar Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîç Validar Input": {
      "main": [
        [
          {
            "node": "üìç Buscar Slots Disponibles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üìç Buscar Slots Disponibles": {
      "main": [
        [
          {
            "node": "‚ùì ¬øHay Slots?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚ùì ¬øHay Slots?": {
      "main": [
        [
          {
            "node": "‚úÖ Respuesta: Disponible",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "üîé Buscar Alternativas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîé Buscar Alternativas": {
      "main": [
        [
          {
            "node": "‚ö†Ô∏è Respuesta: No Disponible",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "968c65341fc947850f62b4a42d249947219a244717952c0dbaf2b62952e73bd9"
  }
}


