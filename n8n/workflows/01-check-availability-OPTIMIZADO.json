{
  "name": "01 - Check Availability (OPTIMIZADO)",
  "nodes": [
    {
      "parameters": {
        "inputSource": "jsonExample",
        "jsonExample": "{\n  \"date\": \"2025-10-19\",\n  \"time\": \"20:00\",\n  \"party_size\": 4,\n  \"preferred_zone\": \"terraza\",\n  \"restaurant_id\": \"d6b63130-1ebf-4284-98fc-a3b31a85d9d1\"\n}"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -752,
        -96
      ],
      "id": "76bd0e89-6b7d-4b1c-b573-169e86b8e81e",
      "name": "Start",
      "notes": "âœ… Acepta preferred_zone (opcional)"
    },
    {
      "parameters": {
        "jsCode": "// =====================================================\n// ğŸ” VALIDACIÃ“N DE INPUT CON SOPORTE DE ZONAS\n// =====================================================\n// NOTA: La validaciÃ³n de tiempo mÃ­nimo se hace en la RPC find_table_combinations\n// que obtiene el valor dinÃ¡micamente de restaurants.settings.min_advance_minutes\n// =====================================================\n\nconst input = $input.first().json;\n\nconsole.log('ğŸ“¥ Input recibido:', input);\n\n// ===== VALIDAR FECHA =====\nconst fecha = input.date || input.reservation_date || '';\n\nif (!fecha || !/^\\d{4}-\\d{2}-\\d{2}$/.test(fecha)) {\n  throw new Error('Formato de fecha invÃ¡lido. Se requiere YYYY-MM-DD');\n}\n\nconst hoy = new Date().toISOString().split('T')[0];\nif (fecha < hoy) {\n  throw new Error('No se puede consultar disponibilidad en fechas pasadas');\n}\n\n// ===== VALIDAR HORA =====\nconst hora = input.time || input.reservation_time || '';\n\nif (!hora || !/^\\d{2}:\\d{2}(:\\d{2})?$/.test(hora)) {\n  throw new Error('Formato de hora invÃ¡lido. Se requiere HH:MM');\n}\n\nconst horaNormalizada = hora.substring(0, 5);\n\n// ===== VALIDAR PERSONAS =====\nconst personas = parseInt(input.party_size || input.people || 0);\n\nif (!personas || personas < 1 || personas > 20) {\n  throw new Error('NÃºmero de personas debe estar entre 1 y 20');\n}\n\n// ===== VALIDAR RESTAURANT_ID =====\nconst restaurant_id = input.restaurant_id || '';\n\nif (!restaurant_id) {\n  throw new Error('restaurant_id es obligatorio');\n}\n\n// ===== CALCULAR TIEMPO HASTA RESERVA (para informaciÃ³n) =====\nconst now = new Date();\nconst reservationDateTime = new Date(`${fecha}T${horaNormalizada}:00`);\nconst minutesUntil = (reservationDateTime - now) / (1000 * 60);\n\nconsole.log(`â° Reserva en ${Math.round(minutesUntil)} minutos. La RPC validarÃ¡ el mÃ­nimo configurado.`);\n\n// ===== VALIDAR Y NORMALIZAR ZONA =====\nconst zonaRaw = input.preferred_zone || input.zone || input.reservation_location || input.location || null;\nconst validZones = ['interior', 'terraza', 'barra', 'privado', 'any'];\nlet zona = null;\n\nif (zonaRaw) {\n  const zonaNormalizada = zonaRaw.toLowerCase().trim();\n  if (validZones.includes(zonaNormalizada)) {\n    zona = zonaNormalizada === 'any' ? null : zonaNormalizada;\n    console.log(`âœ… Zona vÃ¡lida: ${zona || 'todas'}`);\n  } else {\n    console.log(`âš ï¸ Zona invÃ¡lida: \"${zonaRaw}\". Se buscarÃ¡ en todas las zonas.`);\n    zona = null;\n  }\n}\n\nconsole.log('âœ… Validado:', { fecha, hora: horaNormalizada, personas, zona: zona || 'todas', restaurant_id, minutesUntil: Math.round(minutesUntil) });\n\nreturn {\n  fecha,\n  hora: horaNormalizada,\n  personas,\n  zona,\n  restaurant_id,\n  fecha_formateada: new Date(fecha).toLocaleDateString('es-ES', { \n    weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' \n  }),\n  minutes_until_reservation: Math.round(minutesUntil)\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -560,
        -96
      ],
      "id": "3aeea934-02c6-4ef1-b5c4-5812f9ad9ed7",
      "name": "ğŸ” Validar Input",
      "notes": "âœ… Valida zona (opcional)"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "availability_slots",
        "returnAll": true,
        "matchType": "allFilters",
        "filters": {
          "conditions": [
            {
              "keyName": "restaurant_id",
              "condition": "eq",
              "keyValue": "={{ $json.restaurant_id }}"
            },
            {
              "keyName": "slot_date",
              "condition": "eq",
              "keyValue": "={{ $json.fecha }}"
            },
            {
              "keyName": "status",
              "condition": "eq",
              "keyValue": "free"
            },
            {
              "keyName": "start_time",
              "condition": "eq",
              "keyValue": "={{ $json.hora }}"
            },
            {
              "keyName": "zone",
              "condition": "eq",
              "keyValue": "={{ $json.zona }}"
            },
            {
              "keyName": "capacity",
              "condition": "gte",
              "keyValue": "={{ $json.personas }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -368,
        -96
      ],
      "id": "190813d6-cb6e-4267-b624-b42fb0f62e1b",
      "name": "ğŸ“ Buscar Slots Disponibles",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "9pdl4V7ImejCLZWo",
          "name": "Supabase La-IA"
        }
      },
      "continueOnFail": true,
      "notes": "âœ… OPTIMIZADO: Filtra por capacity directamente en BD"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "tiene-slots",
              "leftValue": "={{ $input.all().length }}",
              "rightValue": "0",
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -176,
        -96
      ],
      "id": "dd5a8670-8a83-4813-99cc-5d16cbb33b03",
      "name": "â“ Â¿Hay Slots?",
      "notes": "BifurcaciÃ³n: Disponible vs No disponible"
    },
    {
      "parameters": {
        "jsCode": "// =====================================================\n// âœ… RESPUESTA: SÃ HAY DISPONIBILIDAD (OPTIMIZADO)\n// =====================================================\n\nconst validacion = $('ğŸ” Validar Input').first().json;\nconst slots = $input.all();\n\nconst personas = validacion.personas;\nconst zona = validacion.zona;\n\nconsole.log('âœ… Slots disponibles:', slots.length);\n\nif (slots.length === 0) {\n  const mensajeBase = `Lo siento, no tenemos mesas con capacidad suficiente para ${personas} personas`;\n  const mensajeZona = zona ? ` en la zona ${zona}` : '';\n  const sugerencia = zona ? ' Â¿Te irÃ­a bien en otra zona?' : '';\n  \n  return {\n    disponible: false,\n    mensaje: `${mensajeBase}${mensajeZona}.${sugerencia}`,\n    alternativas: [],\n    detalles: {\n      fecha: validacion.fecha,\n      hora: validacion.hora,\n      personas: personas,\n      zona_solicitada: zona\n    },\n    accion_sugerida: zona ? 'sugerir_otra_zona' : 'buscar_otra_hora'\n  };\n}\n\n// âœ… OPTIMIZADO: capacity y table_name ya vienen en los slots\nconst mesasDisponibles = slots\n  .map(s => s.json)\n  .sort((a, b) => a.capacity - b.capacity);\n\nconst mejorMesa = mesasDisponibles[0];\n\nconst mensajeZona = zona ? ` en ${zona}` : '';\nconst mensaje = `Â¡Perfecto! SÃ­ tenemos disponibilidad${mensajeZona} para ${personas} persona${personas > 1 ? 's' : ''} el ${validacion.fecha_formateada} a las ${validacion.hora}. Tenemos ${mesasDisponibles.length} mesa${mesasDisponibles.length > 1 ? 's' : ''} disponible${mesasDisponibles.length > 1 ? 's' : ''}.`;\n\nreturn {\n  disponible: true,\n  mensaje: mensaje,\n  detalles: {\n    fecha: validacion.fecha,\n    hora: validacion.hora,\n    personas: personas,\n    zona_solicitada: zona,\n    mesas_disponibles: mesasDisponibles.length,\n    mejor_opcion: {\n      mesa: mejorMesa.table_name,  // âœ… Directo desde slot\n      capacidad: mejorMesa.capacity,  // âœ… Directo desde slot\n      zona: mejorMesa.zone\n    },\n    todas_las_opciones: mesasDisponibles.map(m => ({\n      mesa: m.table_name,\n      capacidad: m.capacity,\n      zona: m.zone\n    }))\n  },\n  accion_sugerida: 'proceder_con_reserva'\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        -192
      ],
      "id": "fd13a46e-ae85-44a2-88e4-c1890251a428",
      "name": "âœ… Respuesta: Disponible",
      "notes": "âœ… OPTIMIZADO: Usa capacity y table_name directamente desde slots"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "availability_slots",
        "limit": 200,
        "filters": {
          "conditions": [
            {
              "keyName": "restaurant_id",
              "condition": "eq",
              "keyValue": "={{ $('ğŸ” Validar Input').item.json.restaurant_id }}"
            },
            {
              "keyName": "slot_date",
              "condition": "eq",
              "keyValue": "={{ $('ğŸ” Validar Input').item.json.fecha }}"
            },
            {
              "keyName": "status",
              "condition": "eq",
              "keyValue": "free"
            },
            {
              "keyName": "is_available",
              "condition": "eq",
              "keyValue": "true"
            },
            {
              "keyName": "capacity",
              "condition": "gte",
              "keyValue": "={{ $('ğŸ” Validar Input').item.json.personas }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        0,
        -16
      ],
      "id": "70db53d3-b035-439c-8bab-dffdfbebd6cd",
      "name": "ğŸ” Buscar Alternativas",
      "alwaysOutputData": true,
      "credentials": {
        "supabaseApi": {
          "id": "9pdl4V7ImejCLZWo",
          "name": "Supabase La-IA"
        }
      },
      "continueOnFail": true,
      "notes": "âœ… OPTIMIZADO: Filtra por capacity directamente"
    },
    {
      "parameters": {
        "jsCode": "// =====================================================\n// âš ï¸ RESPUESTA: NO HAY DISPONIBILIDAD (PROFESIONAL)\n// =====================================================\n// Solo ofrece alternativas cercanas (Â±2h, mÃ¡ximo 4 opciones)\n// =====================================================\n\nconst validacion = $('ğŸ” Validar Input').first().json;\nconst alternativas = $input.all();\n\nconst zona = validacion.zona;\nconst personas = validacion.personas;\nconst horaSolicitada = validacion.hora; // formato \"13:00\"\n\nconsole.log('ğŸ” Alternativas encontradas:', alternativas.length);\nconsole.log('ğŸ• Hora solicitada:', horaSolicitada);\n\n// ===== CASO 1: NO HAY ALTERNATIVAS EN TODO EL DÃA =====\nif (alternativas.length === 0) {\n  return {\n    tiene_alternativas: false,\n    mensaje: `Lo siento, no tenemos disponibilidad para ${personas} personas el ${validacion.fecha_formateada}. Â¿Te gustarÃ­a que busque en otra fecha?`,\n    disponible: false,\n    alternativas: [],\n    detalles: {\n      fecha_solicitada: validacion.fecha,\n      hora_solicitada: horaSolicitada,\n      personas: personas,\n      zona_solicitada: zona\n    },\n    accion_sugerida: 'sugerir_otra_fecha'\n  };\n}\n\n// ===== HELPER: Convertir \"HH:MM\" a minutos del dÃ­a =====\nfunction horaAMinutos(hora) {\n  const [h, m] = hora.split(':').map(Number);\n  return h * 60 + m;\n}\n\n// ===== HELPER: Convertir minutos a \"HH:MM\" =====\nfunction minutosAHora(minutos) {\n  const h = Math.floor(minutos / 60);\n  const m = minutos % 60;\n  return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;\n}\n\nconst minutosHoraSolicitada = horaAMinutos(horaSolicitada);\nconst RANGO_MINUTOS = 120; // Â±2 horas = 120 minutos\n\n// ===== CASO 2: FILTRAR ALTERNATIVAS CERCANAS (Â±2h) =====\nconst horasPorSlot = {};\nalternativas.forEach(slot => {\n  const hora = slot.json.start_time.substring(0, 5); // \"13:00:00\" â†’ \"13:00\"\n  const zonaSlot = slot.json.zone;\n  \n  // Filtrar por zona si se especificÃ³\n  if (zona && zonaSlot !== zona) {\n    return;\n  }\n  \n  // Calcular diferencia en minutos\n  const minutosSlot = horaAMinutos(hora);\n  const diferenciaMinutos = Math.abs(minutosSlot - minutosHoraSolicitada);\n  \n  // âœ… SOLO INCLUIR SI ESTÃ DENTRO DEL RANGO DE Â±2H\n  if (diferenciaMinutos > RANGO_MINUTOS) {\n    return;\n  }\n  \n  if (!horasPorSlot[hora]) {\n    horasPorSlot[hora] = {\n      minutos: minutosSlot,\n      diferencia: diferenciaMinutos\n    };\n  }\n});\n\n// ===== CASO 3: ORDENAR POR CERCANÃA Y TOMAR 2 ANTES + 2 DESPUÃ‰S =====\nconst todasLasHoras = Object.keys(horasPorSlot)\n  .filter(h => h !== horaSolicitada) // Excluir hora solicitada\n  .map(h => ({\n    hora: h,\n    minutos: horasPorSlot[h].minutos,\n    diferencia: horasPorSlot[h].diferencia,\n    esAntes: horasPorSlot[h].minutos < minutosHoraSolicitada\n  }));\n\nconst horasAntes = todasLasHoras\n  .filter(h => h.esAntes)\n  .sort((a, b) => b.minutos - a.minutos) // MÃ¡s cercana primero\n  .slice(0, 2)\n  .map(h => h.hora);\n\nconst horasDespues = todasLasHoras\n  .filter(h => !h.esAntes)\n  .sort((a, b) => a.minutos - b.minutos) // MÃ¡s cercana primero\n  .slice(0, 2)\n  .map(h => h.hora);\n\n// Combinar: 2 antes + 2 despuÃ©s, en orden cronolÃ³gico\nconst horasDisponibles = [...horasAntes.reverse(), ...horasDespues];\n\nconsole.log('âœ… Alternativas cercanas (Â±2h):', horasDisponibles);\n\n// ===== CASO 4: SI NO HAY ALTERNATIVAS CERCANAS =====\nif (horasDisponibles.length === 0) {\n  // Verificar si hay en otras zonas\n  if (zona) {\n    const zonasDisponibles = [...new Set(\n      alternativas\n        .map(s => s.json.zone)\n        .filter(z => z && z !== zona)\n    )];\n    \n    if (zonasDisponibles.length > 0) {\n      const listaZonas = zonasDisponibles.join(', ');\n      return {\n        tiene_alternativas: true,\n        disponible: false,\n        mensaje: `Lo siento, no tenemos disponibilidad en ${zona} cerca de las ${horaSolicitada} para ${personas} personas. Sin embargo, sÃ­ tenemos disponibilidad en: ${listaZonas}. Â¿Te irÃ­a bien alguna de estas zonas?`,\n        alternativas_zona: zonasDisponibles,\n        detalles: {\n          fecha: validacion.fecha,\n          hora_solicitada: horaSolicitada,\n          personas: personas,\n          zona_solicitada: zona,\n          zonas_alternativas: zonasDisponibles\n        },\n        accion_sugerida: 'elegir_otra_zona'\n      };\n    }\n  }\n  \n  // No hay alternativas cercanas\n  const mensajeZona = zona ? ` en ${zona}` : '';\n  return {\n    tiene_alternativas: false,\n    disponible: false,\n    mensaje: `Lo siento, no tenemos disponibilidad cerca de las ${horaSolicitada}${mensajeZona} para ${personas} personas el ${validacion.fecha_formateada}. Â¿Te gustarÃ­a que busque en otra fecha?`,\n    alternativas: [],\n    detalles: {\n      fecha: validacion.fecha,\n      hora_solicitada: horaSolicitada,\n      personas: personas,\n      zona_solicitada: zona\n    },\n    accion_sugerida: 'sugerir_otra_fecha'\n  };\n}\n\n// ===== CASO 5: HAY ALTERNATIVAS CERCANAS =====\nconst listaHoras = horasDisponibles.join(', ');\nconst mensajeZona = zona ? ` en ${zona}` : '';\nconst mensaje = `Lo siento, no tenemos disponibilidad a las ${horaSolicitada}${mensajeZona} para ${personas} personas. Sin embargo, sÃ­ tenemos disponibilidad en estos horarios cercanos el ${validacion.fecha_formateada}: ${listaHoras}. Â¿Alguno te vendrÃ­a bien?`;\n\nreturn {\n  tiene_alternativas: true,\n  disponible: false,\n  mensaje: mensaje,\n  alternativas_horario: horasDisponibles,\n  detalles: {\n    fecha: validacion.fecha,\n    hora_solicitada: horaSolicitada,\n    personas: personas,\n    zona_solicitada: zona,\n    total_alternativas: horasDisponibles.length,\n    rango_horas: 'Â±2h'\n  },\n  accion_sugerida: 'elegir_alternativa'\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        192,
        -16
      ],
      "id": "84a78f6a-0683-485d-9833-7be4cb3dfd84",
      "name": "âš ï¸ Respuesta: No Disponible",
      "notes": "âœ… OPTIMIZADO: Usa capacity directamente desde slots"
    }
  ],
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "ğŸ” Validar Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ” Validar Input": {
      "main": [
        [
          {
            "node": "ğŸ“ Buscar Slots Disponibles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“ Buscar Slots Disponibles": {
      "main": [
        [
          {
            "node": "â“ Â¿Hay Slots?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "â“ Â¿Hay Slots?": {
      "main": [
        [
          {
            "node": "âœ… Respuesta: Disponible",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ğŸ” Buscar Alternativas",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ” Buscar Alternativas": {
      "main": [
        [
          {
            "node": "âš ï¸ Respuesta: No Disponible",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "968c65341fc947850f62b4a42d249947219a244717952c0dbaf2b62952e73bd9"
  }
}


