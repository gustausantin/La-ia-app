Ticket

T√≠tulo: Dashboard en ‚Äúcargando‚Äù infinito. fetchRestaurantInfo no completa (isReady nunca llega a true).

Hechos:

Los logs muestran fetchRestaurantInfo inicia pero no vemos ‚úÖ fetchRestaurantInfo COMPLETED.

La UI s√≥lo muestra datos tras pulsar Actualizar.

Sospecha: cuelgue en llamada a Supabase o rama no manejada; falta finally que garantice isReady = true.

Resultado esperado:

Al entrar, una sola carga autom√°tica. Si la API falla o tarda, salir del estado de carga (mostrar error), nunca bucle infinito.

Patch propuesto (AuthContext.jsx)

Idea clave: convertir isReady en garant√≠a, no en ‚Äúsi todo va bien‚Äù.

finally en todas las rutas cr√≠ticas.

Timeout defensivo en fetch a Supabase.

Evitar dejar loading=true si algo falla.

Reemplazar las funciones por estas (copy-paste):

// Helper: timeout defensivo
const withTimeout = (p, ms = 12000, label = 'OP') =>
  Promise.race([
    p,
    new Promise((_, rej) => setTimeout(() => rej(new Error(`TIMEOUT_${label}`)), ms))
  ]);

const initSession = async () => {
  console.log('üöÄ Initializing auth...');
  setLoading(true);
  try {
    const { data: { session }, error } = await withTimeout(
      supabase.auth.getSession(),
      12000,
      'GET_SESSION'
    );
    if (error) throw error;

    if (session?.user) {
      console.log('‚úÖ Session found:', session.user.email);
      await loadUserData(session.user);
    } else {
      console.log('‚ùå No session found');
    }
  } catch (err) {
    console.error('‚ùå Error in initSession:', err?.message || err);
  } finally {
    // Pase lo que pase, salimos de "cargando"
    setLoading(false);
    setIsReady(true);
  }
};

const fetchRestaurantInfo = async (userId) => {
  console.log('üîç Starting fetchRestaurantInfo for user:', userId);
  if (!userId) {
    console.warn('‚ö†Ô∏è No userId; skipping restaurant fetch');
    setRestaurant(null);
    setRestaurantId(null);
    setIsReady(true);
    return;
  }

  try {
    // mapping -> restaurant
    const { data: mappingData, error: mappingError } = await withTimeout(
      supabase
        .from('user_restaurant_mapping')
        .select(`
          role,
          permissions,
          restaurant:restaurant_id (
            id, name, email, phone, address, city, postal_code, country,
            timezone, currency, logo_url, website, active, trial_end_at,
            subscription_status, agent_config, settings, created_at, updated_at,
            ui_cuisine_type
          )
        `)
        .eq('auth_user_id', userId)
        .single(),
      12000,
      'MAP_RESTAURANT'
    );

    if (!mappingError && mappingData?.restaurant) {
      console.log('‚úÖ Restaurant via mapping:', mappingData.restaurant.name);
      setRestaurant(mappingData.restaurant);
      setRestaurantId(mappingData.restaurant.id);
      return;
    }

    if (mappingError && mappingError.code === 'PGRST116') {
      console.log('üè™ No mapping; querying restaurants directly');
      const { data: restaurantData, error: restaurantError } = await withTimeout(
        supabase.from('restaurants').select('*').eq('auth_user_id', userId).single(),
        12000,
        'DIRECT_RESTAURANT'
      );

      if (!restaurantError && restaurantData) {
        console.log('‚úÖ Restaurant direct:', restaurantData.name);
        setRestaurant(restaurantData);
        setRestaurantId(restaurantData.id);
      } else {
        console.log('üè™ No restaurant found');
        setRestaurant(null);
        setRestaurantId(null);
      }
      return;
    }

    // Error real de DB
    if (mappingError) {
      console.error('‚ùå DB error (mapping):', mappingError);
      setRestaurant(null);
      setRestaurantId(null);
    }
  } catch (err) {
    console.error('‚ùå fetchRestaurantInfo error:', err?.message || err);
    setRestaurant(null);
    setRestaurantId(null);
  } finally {
    console.log('üéØ Setting isReady = true after fetchRestaurantInfo');
    setIsReady(true);
    console.log('‚úÖ fetchRestaurantInfo COMPLETED');
  }
};

const loadUserData = async (user) => {
  console.log('üîÑ Loading user data for:', user.email);
  setUser(user);
  setIsAuthenticated(true);
  setLoading(true);
  try {
    await fetchRestaurantInfo(user.id);
  } finally {
    setLoading(false);
    // isReady ya se setea dentro de fetchRestaurantInfo, pero aseguramos
    setIsReady(true);
    console.log('‚úÖ loadUserData completed');
  }
};


Auth listener (sin cambios funcionales, pero estable):

Mantener tu onAuthStateChange, pero aseg√∫rate de que todas las ramas hacen setIsReady(true) en finally si hay logout.

Ajuste en Dashboard (resumen)

En la vista, usar const ready = isReady && !loading; y condicionar el spinner a !ready.

Disparar una sola carga autom√°tica al montar (no exigir pulsar Actualizar).

Si falla, mostrar error y datos vac√≠os; nunca dejar spinner infinito.

Por qu√© esto corta el bug

Si Supabase cuelga/rompe, el Promise.race suelta TIMEOUT y pasamos por finally.

isReady se marca siempre en finally. No queda la app atrapada.

loading tambi√©n se cierra en finally, evitando estados inconsistentes.

Si quieres, te preparo el diff completo del archivo con este patch aplicado.

ChatGPT puede cometer errores. OpenAI no usa datos del √°rea de tr